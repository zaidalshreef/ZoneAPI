name: CI/CD Pipeline

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master ]

env:
  IMAGE_NAME: zoneapi
  HELM_VERSION: 3.12.0

jobs:
  # Build and Test Job
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 7.0.x
    
    - name: Restore dependencies
      run: dotnet restore ZoneAPI/ZoneAPI.csproj
    
    - name: Build application
      run: dotnet build ZoneAPI/ZoneAPI.csproj --no-restore --configuration Release
    
    - name: Run tests
      run: dotnet test ZoneAPI/ZoneAPI.csproj --no-build --configuration Release --verbosity normal
    
    # Upload build artifacts
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts
        path: ZoneAPI/bin/Release/
        retention-days: 1

  # Infrastructure Deployment Job
  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    outputs:
      aks-cluster-name: ${{ steps.terraform-output.outputs.aks-cluster-name }}
      resource-group: ${{ steps.terraform-output.outputs.resource-group }}
      postgres-host: ${{ steps.terraform-output.outputs.postgres-host }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    - name: Terraform Format Check
      run: terraform fmt -check
      working-directory: ./terraform
    
    - name: Setup Terraform Backend (if needed)
      run: |
        # Check if backend storage account exists, create if not
        if ! az storage account show --name tfstatezoneapi --resource-group rg-terraform-state >/dev/null 2>&1; then
          echo "Setting up Terraform backend..."
          ./scripts/setup-terraform-backend.sh
        else
          echo "Terraform backend already exists"
        fi
    
    - name: Terraform Init
      run: terraform init
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    - name: Terraform Plan
      run: terraform plan -out=tfplan
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_VAR_postgres_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
    
    - name: Terraform Apply
      run: terraform apply -auto-approve tfplan
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_VAR_postgres_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
    
    - name: Get Terraform Outputs
      id: terraform-output
      run: |
        echo "aks-cluster-name=$(terraform output -raw aks_cluster_name)" >> $GITHUB_OUTPUT
        echo "resource-group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
        echo "postgres-host=$(terraform output -raw postgres_server_fqdn)" >> $GITHUB_OUTPUT
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

  # Docker Build and Push Job
  docker-build-push:
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    outputs:
      image-tag: ${{ steps.image-tag.outputs.tag }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Generate image tag
      id: image-tag
      run: |
        if [ "${{ github.ref }}" == "refs/heads/main" ] || [ "${{ github.ref }}" == "refs/heads/master" ]; then
          echo "tag=latest" >> $GITHUB_OUTPUT
        else
          echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
        fi
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    - name: Get ACR login server from Terraform
      id: acr-info
      run: |
        cd terraform
        terraform init
        ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
        ACR_USERNAME=$(terraform output -raw acr_admin_username)
        ACR_PASSWORD=$(terraform output -raw acr_admin_password)
        echo "::add-mask::$ACR_PASSWORD"
        echo "login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
        echo "username=$ACR_USERNAME" >> $GITHUB_OUTPUT
        echo "password=$ACR_PASSWORD" >> $GITHUB_OUTPUT
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ steps.acr-info.outputs.login-server }}
        username: ${{ steps.acr-info.outputs.username }}
        password: ${{ steps.acr-info.outputs.password }}
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.acr-info.outputs.login-server }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}
        labels: |
          org.opencontainers.image.title=${{ env.IMAGE_NAME }}
          org.opencontainers.image.description=ZoneAPI - Healthcare Appointment Management System
          org.opencontainers.image.source=${{ github.repository }}
          org.opencontainers.image.revision=${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Application Deployment Job
  deploy-application:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, docker-build-push]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ needs.deploy-infrastructure.outputs.resource-group }} \
          --name ${{ needs.deploy-infrastructure.outputs.aks-cluster-name }} \
          --overwrite-existing
    
    - name: Get ACR login server from Terraform
      id: acr-info
      run: |
        cd terraform
        terraform init
        ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
        echo "login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    - name: Create namespace if not exists
      run: |
        kubectl create namespace zoneapi --dry-run=client -o yaml | kubectl apply -f -
    
    - name: Test database connection first
      run: |
        echo "=== Testing database connection before deployment ==="
        echo "Database endpoint: ${{ needs.deploy-infrastructure.outputs.postgres-host }}"
        
        # Create database secret first
        kubectl create secret generic zoneapi-db-secret \
          --from-literal=password="${{ secrets.POSTGRES_ADMIN_PASSWORD }}" \
          --namespace=zoneapi \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # Create a simple connection test pod
        kubectl run zoneapi-connection-test \
          --namespace=zoneapi \
          --image=postgres:15-alpine \
          --restart=Never \
          --rm -i --tty=false \
          --env="PGPASSWORD=${{ secrets.POSTGRES_ADMIN_PASSWORD }}" \
          --command -- /bin/bash -c "
            echo '=== Database Connection Test ==='
            echo 'Host: ${{ needs.deploy-infrastructure.outputs.postgres-host }}'
            echo 'Port: 5432'
            echo 'Database: zone'
            echo 'User: postgres'
            echo ''
            
            echo 'Step 1: Testing DNS resolution...'
            nslookup ${{ needs.deploy-infrastructure.outputs.postgres-host }} || echo 'DNS failed'
            
            echo 'Step 2: Testing network connectivity...'
            nc -zv ${{ needs.deploy-infrastructure.outputs.postgres-host }} 5432 || echo 'Network failed'
            
            echo 'Step 3: Testing PostgreSQL service...'
            pg_isready -h ${{ needs.deploy-infrastructure.outputs.postgres-host }} -p 5432 -U postgres
            
            echo 'Step 4: Testing authentication...'
            psql -h ${{ needs.deploy-infrastructure.outputs.postgres-host }} -p 5432 -U postgres -d postgres -c 'SELECT version();'
            
            echo 'Step 5: Testing database zone access...'
            psql -h ${{ needs.deploy-infrastructure.outputs.postgres-host }} -p 5432 -U postgres -d zone -c 'SELECT current_database();' || echo 'Database zone does not exist, will be created by migration'
            
            echo '✅ Connection test completed'
          " || (echo "❌ Database connection test failed" && exit 1)
        
        echo "✅ Database connection test passed!"

    - name: Deploy application with Helm
      run: |
        echo "=== Deploying ZoneAPI with debug enabled ==="
        helm upgrade --install zoneapi ./charts/zoneapi \
          --namespace zoneapi \
          --set image.repository=${{ steps.acr-info.outputs.login-server }}/${{ env.IMAGE_NAME }} \
          --set image.tag=${{ needs.docker-build-push.outputs.image-tag }} \
          --set database.host=${{ needs.deploy-infrastructure.outputs.postgres-host }} \
          --set database.password=${{ secrets.POSTGRES_ADMIN_PASSWORD }} \
          --set debug.enabled=true \
          --set migration.timeout=120 \
          --set ingress.hosts[0].host=zoneapi-${{ github.run_number }}.example.com \
          --set ingress.hosts[0].paths[0].path=/ \
          --set ingress.hosts[0].paths[0].pathType=Prefix \
          --set ingress.tls[0].hosts[0]=zoneapi-${{ github.run_number }}.example.com \
          --debug --wait --timeout=5m
    
    - name: Debug migration job logs
      if: failure()
      run: |
        echo "=== Checking migration job status ==="
        kubectl get jobs --namespace=zoneapi -l app.kubernetes.io/component=migration
        
        echo "=== Migration job logs ==="
        kubectl logs --namespace=zoneapi -l app.kubernetes.io/component=migration --tail=100 || echo "No migration logs found"
        
        echo "=== Debug migration job logs ==="
        kubectl logs --namespace=zoneapi -l app.kubernetes.io/component=debug-migration --tail=100 || echo "No debug migration logs found"
        
        echo "=== Recent events ==="
        kubectl get events --namespace=zoneapi --sort-by='.lastTimestamp' | tail -20
    
    - name: Check deployment status
      run: |
        echo "=== Checking deployment progress ==="
        kubectl get pods --namespace=zoneapi -o wide
        kubectl get events --namespace=zoneapi --sort-by='.lastTimestamp' | tail -10
        
    - name: Verify deployment
      run: |
        kubectl get pods --namespace=zoneapi
        kubectl get services --namespace=zoneapi
        kubectl get ingress --namespace=zoneapi
    
    - name: Run health check
      run: |
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=zoneapi --namespace=zoneapi --timeout=300s
        kubectl port-forward svc/zoneapi 8080:8080 --namespace=zoneapi &
        sleep 10
        curl -f http://localhost:8080/health || exit 1

  # Security Scanning Job
  security-scan:
    runs-on: ubuntu-latest
    needs: [docker-build-push, deploy-infrastructure]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    - name: Get ACR credentials from Terraform
      id: acr-creds
      run: |
        cd terraform
        terraform init
        ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
        ACR_USERNAME=$(terraform output -raw acr_admin_username)
        ACR_PASSWORD=$(terraform output -raw acr_admin_password)
        echo "::add-mask::$ACR_PASSWORD"
        echo "login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
        echo "username=$ACR_USERNAME" >> $GITHUB_OUTPUT
        echo "password=$ACR_PASSWORD" >> $GITHUB_OUTPUT
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ steps.acr-creds.outputs.login-server }}
        username: ${{ steps.acr-creds.outputs.username }}
        password: ${{ steps.acr-creds.outputs.password }}
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.acr-creds.outputs.login-server }}/${{ env.IMAGE_NAME }}:${{ needs.docker-build-push.outputs.image-tag }}
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif' 