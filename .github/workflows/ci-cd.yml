name: CI/CD Pipeline

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master ]

env:
  REGISTRY: ${{ secrets.ACR_LOGIN_SERVER }}
  IMAGE_NAME: zoneapi
  HELM_VERSION: 3.12.0

jobs:
  # Build and Test Job
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 7.0.x
    
    - name: Restore dependencies
      run: dotnet restore ZoneAPI/ZoneAPI.csproj
    
    - name: Build application
      run: dotnet build ZoneAPI/ZoneAPI.csproj --no-restore --configuration Release
    
    - name: Run tests
      run: dotnet test ZoneAPI/ZoneAPI.csproj --no-build --configuration Release --verbosity normal
    
    # Upload build artifacts
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts
        path: ZoneAPI/bin/Release/
        retention-days: 1

  # Docker Build and Push Job
  docker-build-push:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'
    
    outputs:
      image-tag: ${{ steps.image-tag.outputs.tag }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Generate image tag
      id: image-tag
      run: |
        if [ "${{ github.ref }}" == "refs/heads/main" ] || [ "${{ github.ref }}" == "refs/heads/master" ]; then
          echo "tag=latest" >> $GITHUB_OUTPUT
        else
          echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
        fi
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: false
        tags: ${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}
        labels: |
          org.opencontainers.image.title=${{ env.IMAGE_NAME }}
          org.opencontainers.image.description=ZoneAPI - Healthcare Appointment Management System
          org.opencontainers.image.source=${{ github.repository }}
          org.opencontainers.image.revision=${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Infrastructure Deployment Job
  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: docker-build-push
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    outputs:
      aks-cluster-name: ${{ steps.terraform-output.outputs.aks-cluster-name }}
      resource-group: ${{ steps.terraform-output.outputs.resource-group }}
      postgres-host: ${{ steps.terraform-output.outputs.postgres-host }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    - name: Terraform Format Check
      run: terraform fmt -check
      working-directory: ./terraform
    
    - name: Terraform Init
      run: terraform init
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    - name: Terraform Plan
      run: terraform plan -out=tfplan
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_VAR_postgres_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
    
    - name: Terraform Apply
      run: terraform apply -auto-approve tfplan
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_VAR_postgres_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
    
    - name: Get Terraform Outputs
      id: terraform-output
      run: |
        echo "aks-cluster-name=$(terraform output -raw aks_cluster_name)" >> $GITHUB_OUTPUT
        echo "resource-group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
        echo "postgres-host=$(terraform output -raw postgres_server_fqdn)" >> $GITHUB_OUTPUT
      working-directory: ./terraform

  # Application Deployment Job
  deploy-application:
    runs-on: ubuntu-latest
    needs: [docker-build-push, deploy-infrastructure]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}
    
    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ needs.deploy-infrastructure.outputs.resource-group }} \
          --name ${{ needs.deploy-infrastructure.outputs.aks-cluster-name }} \
          --overwrite-existing
    
    - name: Create namespace if not exists
      run: |
        kubectl create namespace zoneapi --dry-run=client -o yaml | kubectl apply -f -
    
    - name: Run database migrations
      run: |
        kubectl run migration-job-${{ github.run_number }} \
          --image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.docker-build-push.outputs.image-tag }} \
          --restart=Never \
          --namespace=zoneapi \
          --env="ASPNETCORE_ENVIRONMENT=Production" \
          --env="DB_HOST=${{ needs.deploy-infrastructure.outputs.postgres-host }}" \
          --env="DB_PORT=5432" \
          --env="DB_NAME=zone" \
          --env="DB_USER=postgres" \
          --env="DB_PASSWORD=${{ secrets.POSTGRES_ADMIN_PASSWORD }}" \
          --command -- dotnet ef database update --project ZoneAPI.csproj
        
        kubectl wait --for=condition=complete job/migration-job-${{ github.run_number }} --namespace=zoneapi --timeout=300s
        kubectl delete job migration-job-${{ github.run_number }} --namespace=zoneapi
    
    - name: Deploy application with Helm
      run: |
        helm upgrade --install zoneapi ./charts/zoneapi \
          --namespace zoneapi \
          --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
          --set image.tag=${{ needs.docker-build-push.outputs.image-tag }} \
          --set database.host=${{ needs.deploy-infrastructure.outputs.postgres-host }} \
          --set database.password=${{ secrets.POSTGRES_ADMIN_PASSWORD }} \
          --set ingress.hosts[0].host=zoneapi-${{ github.run_number }}.example.com \
          --wait --timeout=10m
    
    - name: Verify deployment
      run: |
        kubectl get pods --namespace=zoneapi
        kubectl get services --namespace=zoneapi
        kubectl get ingress --namespace=zoneapi
    
    - name: Run health check
      run: |
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=zoneapi --namespace=zoneapi --timeout=300s
        kubectl port-forward svc/zoneapi 8080:80 --namespace=zoneapi &
        sleep 10
        curl -f http://localhost:8080/health || exit 1

  # Security Scanning Job
  security-scan:
    runs-on: ubuntu-latest
    needs: docker-build-push
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ secrets.ACR_LOGIN_SERVER }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.docker-build-push.outputs.image-tag }}
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif' 