name: CI/CD Pipeline

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master ]

env:
  IMAGE_NAME: zoneapi
  HELM_VERSION: 3.12.0

jobs:
  # Build and Test Job
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 7.0.x
    
    - name: Restore dependencies
      run: dotnet restore ZoneAPI/ZoneAPI.csproj
    
    - name: Build application
      run: dotnet build ZoneAPI/ZoneAPI.csproj --no-restore --configuration Release
    
    - name: Run tests
      run: dotnet test ZoneAPI/ZoneAPI.csproj --no-build --configuration Release --verbosity normal
    
    # Upload build artifacts
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts
        path: ZoneAPI/bin/Release/
        retention-days: 1

  # Infrastructure Deployment Job
  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    outputs:
      aks-cluster-name: ${{ steps.terraform-output.outputs.aks-cluster-name }}
      resource-group: ${{ steps.terraform-output.outputs.resource-group }}
      postgres-host: ${{ steps.terraform-output.outputs.postgres-host }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    - name: Terraform Format Check
      run: terraform fmt -check
      working-directory: ./terraform
    
    - name: Setup Terraform Backend (if needed)
      run: |
        # Check if backend storage account exists, create if not
        if ! az storage account show --name tfstatezoneapi --resource-group rg-terraform-state >/dev/null 2>&1; then
          echo "Setting up Terraform backend..."
          ./scripts/setup-terraform-backend.sh
        else
          echo "Terraform backend already exists"
        fi
    
    - name: Terraform Init
      run: terraform init
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    - name: Terraform Plan
      run: terraform plan -out=tfplan
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_VAR_postgres_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
    
    - name: Terraform Apply
      run: terraform apply -auto-approve tfplan
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_VAR_postgres_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
    
    - name: Get Terraform Outputs
      id: terraform-output
      run: |
        echo "aks-cluster-name=$(terraform output -raw aks_cluster_name)" >> $GITHUB_OUTPUT
        echo "resource-group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
        echo "postgres-host=$(terraform output -raw postgres_server_fqdn)" >> $GITHUB_OUTPUT
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

  # Docker Build and Push Job
  docker-build-push:
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    outputs:
      image-tag: ${{ steps.image-tag.outputs.tag }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Generate image tag
      id: image-tag
      run: |
        if [ "${{ github.ref }}" == "refs/heads/main" ] || [ "${{ github.ref }}" == "refs/heads/master" ]; then
          echo "tag=latest" >> $GITHUB_OUTPUT
        else
          echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
        fi
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    - name: Get ACR login server from Terraform
      id: acr-info
      run: |
        # Setup Terraform backend (since this is a separate job)
        if ! az storage account show --name tfstatezoneapi --resource-group rg-terraform-state >/dev/null 2>&1; then
          echo "Setting up Terraform backend..."
          ./scripts/setup-terraform-backend.sh
        else
          echo "Terraform backend already exists"
        fi
        
        cd terraform
        # Initialize Terraform with backend
        terraform init
        ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
        ACR_USERNAME=$(terraform output -raw acr_admin_username)
        ACR_PASSWORD=$(terraform output -raw acr_admin_password)
        echo "::add-mask::$ACR_PASSWORD"
        echo "login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
        echo "username=$ACR_USERNAME" >> $GITHUB_OUTPUT
        echo "password=$ACR_PASSWORD" >> $GITHUB_OUTPUT
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ steps.acr-info.outputs.login-server }}
        username: ${{ steps.acr-info.outputs.username }}
        password: ${{ steps.acr-info.outputs.password }}
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.acr-info.outputs.login-server }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}
        labels: |
          org.opencontainers.image.title=${{ env.IMAGE_NAME }}
          org.opencontainers.image.description=ZoneAPI - Healthcare Appointment Management System
          org.opencontainers.image.source=${{ github.repository }}
          org.opencontainers.image.revision=${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Migration Job (Separate from deployment)
  run-migration:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, docker-build-push]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ needs.deploy-infrastructure.outputs.resource-group }} \
          --name ${{ needs.deploy-infrastructure.outputs.aks-cluster-name }} \
          --overwrite-existing

    - name: Setup ACR authentication for AKS
      run: |
        echo "=== Setting up ACR authentication ==="
        
        # Setup Terraform backend first (since this is a separate job)
        if ! az storage account show --name tfstatezoneapi --resource-group rg-terraform-state >/dev/null 2>&1; then
          echo "Setting up Terraform backend..."
          ./scripts/setup-terraform-backend.sh
        else
          echo "Terraform backend already exists"
        fi
        
        # Initialize Terraform with backend
        cd terraform
        terraform init
        
        # Get ACR credentials
        ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
        ACR_USERNAME=$(terraform output -raw acr_admin_username)
        ACR_PASSWORD=$(terraform output -raw acr_admin_password)
        
        echo "ACR Login Server: $ACR_LOGIN_SERVER"
        
        # Create or update image pull secret
        kubectl create secret docker-registry acr-secret \
          --docker-server="$ACR_LOGIN_SERVER" \
          --docker-username="$ACR_USERNAME" \
          --docker-password="$ACR_PASSWORD" \
          --namespace=zoneapi \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # Verify the secret was created
        kubectl get secret acr-secret --namespace=zoneapi
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

    - name: Get ACR login server from Terraform
      id: acr-info
      run: |
        # Setup Terraform backend (since this is a separate job)
        if ! az storage account show --name tfstatezoneapi --resource-group rg-terraform-state >/dev/null 2>&1; then
          echo "Setting up Terraform backend..."
          ./scripts/setup-terraform-backend.sh
        else
          echo "Terraform backend already exists"
        fi
        
        cd terraform
        # Initialize Terraform with backend
        terraform init
        ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
        echo "login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    - name: Create namespace and secrets
      run: |
        echo "=== Creating namespace and secrets ==="
        kubectl create namespace zoneapi --dry-run=client -o yaml | kubectl apply -f -
        
        # Create database secret
        kubectl create secret generic zoneapi-db-secret \
          --from-literal=password="${{ secrets.POSTGRES_ADMIN_PASSWORD }}" \
          --namespace=zoneapi \
          --dry-run=client -o yaml | kubectl apply -f -
        
        echo "✅ Namespace and secrets created"

    - name: Test database connection thoroughly
      run: |
        echo "=== DETAILED Database Connection Test ==="
        echo "Database endpoint: ${{ needs.deploy-infrastructure.outputs.postgres-host }}"
        echo "Testing from pod inside cluster..."
        
        # Create a detailed connection test pod
        kubectl run zoneapi-db-test \
          --namespace=zoneapi \
          --image=postgres:15-alpine \
          --restart=Never \
          --rm -i --tty=false \
          --env="PGPASSWORD=${{ secrets.POSTGRES_ADMIN_PASSWORD }}" \
          --timeout=300s \
          --command -- /bin/bash -c "
            echo '=== COMPREHENSIVE Database Connection Test ==='
            echo 'Host: ${{ needs.deploy-infrastructure.outputs.postgres-host }}'
            echo 'Port: 5432'
            echo 'Database: zone'
            echo 'User: postgres'
            echo 'Password: [MASKED]'
            echo ''
            
            echo '=== Step 1: DNS Resolution ==='
            nslookup ${{ needs.deploy-infrastructure.outputs.postgres-host }}
            
            echo '=== Step 2: Network Connectivity ==='
            nc -zv ${{ needs.deploy-infrastructure.outputs.postgres-host }} 5432
            
            echo '=== Step 3: PostgreSQL Service Check ==='
            pg_isready -h ${{ needs.deploy-infrastructure.outputs.postgres-host }} -p 5432 -U postgres -v
            
            echo '=== Step 4: Authentication Test ==='
            psql -h ${{ needs.deploy-infrastructure.outputs.postgres-host }} -p 5432 -U postgres -d postgres -c 'SELECT version();'
            
            echo '=== Step 5: Database Zone Test ==='
            psql -h ${{ needs.deploy-infrastructure.outputs.postgres-host }} -p 5432 -U postgres -d zone -c 'SELECT current_database(), current_user, now();' || echo 'Database zone does not exist yet'
            
            echo '=== Step 6: Connection String Test ==='
            # Test the exact connection string format we use
            CONNECTION_STRING='Host=${{ needs.deploy-infrastructure.outputs.postgres-host }};Port=5432;Database=zone;Username=postgres;Password=${{ secrets.POSTGRES_ADMIN_PASSWORD }};CommandTimeout=300;Timeout=60;'
            echo \"Connection string format: \$CONNECTION_STRING\"
            
            echo '✅ All database tests completed'
          " || (echo "❌ Database connection test failed" && kubectl describe pod zoneapi-db-test -n zoneapi && exit 1)
        
        echo "✅ Database connection test passed!"

    - name: Run Migration Only (Separate Job)
      run: |
        echo "=== RUNNING MIGRATION ONLY ==="
        echo "Image: ${{ steps.acr-info.outputs.login-server }}/${{ env.IMAGE_NAME }}:${{ needs.docker-build-push.outputs.image-tag }}"
        
        # Deploy only migration job
        helm upgrade --install zoneapi-migration ./charts/zoneapi \
          --namespace zoneapi \
          --set migration.enabled=true \
          --set replicaCount=0 \
          --set image.repository=${{ steps.acr-info.outputs.login-server }}/${{ env.IMAGE_NAME }} \
          --set image.tag=${{ needs.docker-build-push.outputs.image-tag }} \
          --set imagePullSecrets[0].name=acr-secret \
          --set database.host=${{ needs.deploy-infrastructure.outputs.postgres-host }} \
          --set database.password=${{ secrets.POSTGRES_ADMIN_PASSWORD }} \
          --wait --timeout=5m \
          --debug
    
    - name: Check Migration Results
      if: always()
      run: |
        echo "=== MIGRATION JOB STATUS ==="
        kubectl get jobs -n zoneapi -o wide
        
        echo "=== MIGRATION JOB LOGS ==="
        kubectl logs --namespace=zoneapi -l app.kubernetes.io/component=migration --tail=100 || echo "No migration logs found"
        
        echo "=== MIGRATION EVENTS ==="
        kubectl get events --namespace=zoneapi --sort-by='.lastTimestamp' | tail -20

  # Application Deployment Job (Separate from migration)
  deploy-application:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, docker-build-push, run-migration]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ needs.deploy-infrastructure.outputs.resource-group }} \
          --name ${{ needs.deploy-infrastructure.outputs.aks-cluster-name }} \
          --overwrite-existing

    - name: Get ACR login server from Terraform
      id: acr-info
      run: |
        # Setup Terraform backend (since this is a separate job)
        if ! az storage account show --name tfstatezoneapi --resource-group rg-terraform-state >/dev/null 2>&1; then
          echo "Setting up Terraform backend..."
          ./scripts/setup-terraform-backend.sh
        else
          echo "Terraform backend already exists"
        fi
        
        cd terraform
        # Initialize Terraform with backend
        terraform init
        ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
        echo "login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    - name: Deploy application with NO HEALTH CHECKS (Debug Mode)
      timeout-minutes: 10
      run: |
        echo "=== DEPLOYING APPLICATION (DEBUG MODE) ==="
        echo "Image: ${{ steps.acr-info.outputs.login-server }}/${{ env.IMAGE_NAME }}:${{ needs.docker-build-push.outputs.image-tag }}"
        echo "Database: ${{ needs.deploy-infrastructure.outputs.postgres-host }}"
        
        # Deploy with health checks DISABLED for debugging
        helm upgrade --install zoneapi ./charts/zoneapi \
          --namespace zoneapi \
          --set migration.enabled=false \
          --set image.repository=${{ steps.acr-info.outputs.login-server }}/${{ env.IMAGE_NAME }} \
          --set image.tag=${{ needs.docker-build-push.outputs.image-tag }} \
          --set imagePullSecrets[0].name=acr-secret \
          --set database.host=${{ needs.deploy-infrastructure.outputs.postgres-host }} \
          --set database.password=${{ secrets.POSTGRES_ADMIN_PASSWORD }} \
          --set livenessProbe.enabled=false \
          --set readinessProbe.enabled=false \
          --set healthCheck.enabled=false \
          --set replicaCount=1 \
          --wait --timeout=8m \
          --debug
    
    - name: Detailed Pod Analysis
      if: always()
      run: |
        echo "=== DETAILED POD ANALYSIS ==="
        
        echo "=== Cluster Resources ==="
        kubectl get nodes -o wide
        kubectl top nodes || echo "Metrics not available"
        
        echo "=== Namespace Resources ==="
        kubectl get all -n zoneapi -o wide
        
        echo "=== Pod Details ==="
        kubectl get pods -n zoneapi -o wide
        kubectl describe pods -n zoneapi
        
        echo "=== Pod Logs ==="
        for pod in $(kubectl get pods -n zoneapi -o jsonpath='{.items[*].metadata.name}'); do
          echo "--- Logs for pod: $pod ---"
          kubectl logs $pod -n zoneapi --tail=100 || echo "No logs for $pod"
        done
        
        echo "=== Recent Events ==="
        kubectl get events -n zoneapi --sort-by='.lastTimestamp' | tail -30
        
        echo "=== Service and Endpoints ==="
        kubectl get services -n zoneapi -o wide
        kubectl get endpoints -n zoneapi -o wide
    
    - name: Manual Health Check Test
      if: always()
      run: |
        echo "=== MANUAL HEALTH CHECK TEST ==="
        
        # Get pod name
        pod_name=$(kubectl get pods -n zoneapi -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
        
        if [ -n "$pod_name" ]; then
          echo "Testing pod: $pod_name"
          
          # Wait for pod to be running
          kubectl wait --for=condition=ready pod/$pod_name -n zoneapi --timeout=60s || echo "Pod not ready within 60s"
          
          # Test health endpoint directly
          echo "Testing health endpoint..."
          kubectl exec -n zoneapi $pod_name -- curl -v http://localhost:8080/health || echo "Health endpoint failed"
          
          # Test root endpoint
          echo "Testing root endpoint..."
          kubectl exec -n zoneapi $pod_name -- curl -v http://localhost:8080/ || echo "Root endpoint failed"
          
          # Check if app is listening
          echo "Checking listening ports..."
          kubectl exec -n zoneapi $pod_name -- netstat -tulpn | grep 8080 || echo "Port 8080 not listening"
          
          # Check environment variables
          echo "Environment variables:"
          kubectl exec -n zoneapi $pod_name -- env | grep -E "(ASPNETCORE|DB_|ConnectionStrings)" || echo "No relevant env vars"
        else
          echo "No pods found to test"
        fi 