name: CI/CD Pipeline

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master ]

env:
  IMAGE_NAME: zoneapi
  HELM_VERSION: 3.12.0

jobs:
  # Build and Test Job
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 7.0.x
    
    - name: Restore dependencies
      run: dotnet restore ZoneAPI/ZoneAPI.csproj
    
    - name: Build application
      run: dotnet build ZoneAPI/ZoneAPI.csproj --no-restore --configuration Release
    
    - name: Run tests
      run: dotnet test ZoneAPI/ZoneAPI.csproj --no-build --configuration Release --verbosity normal
    
    # Upload build artifacts
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts
        path: ZoneAPI/bin/Release/
        retention-days: 1

  # Infrastructure Deployment Job
  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    outputs:
      aks-cluster-name: ${{ steps.terraform-output.outputs.aks-cluster-name }}
      resource-group: ${{ steps.terraform-output.outputs.resource-group }}
      postgres-host: ${{ steps.terraform-output.outputs.postgres-host }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    - name: Terraform Format Check
      run: terraform fmt -check
      working-directory: ./terraform
    
    - name: Setup Terraform Backend (if needed)
      run: |
        # Check if backend storage account exists, create if not
        if ! az storage account show --name tfstatezoneapi --resource-group rg-terraform-state >/dev/null 2>&1; then
          echo "Setting up Terraform backend..."
          ./scripts/setup-terraform-backend.sh
        else
          echo "Terraform backend already exists"
        fi
    
    - name: Terraform Init
      run: terraform init
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    - name: Terraform Plan
      run: terraform plan -out=tfplan
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_VAR_postgres_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
    
    - name: Terraform Apply
      run: terraform apply -auto-approve tfplan
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_VAR_postgres_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
    
    - name: Get Terraform Outputs
      id: terraform-output
      run: |
        echo "aks-cluster-name=$(terraform output -raw aks_cluster_name)" >> $GITHUB_OUTPUT
        echo "resource-group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
        echo "postgres-host=$(terraform output -raw postgres_server_fqdn)" >> $GITHUB_OUTPUT
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

  # Docker Build and Push Job
  docker-build-push:
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    outputs:
      image-tag: ${{ steps.image-tag.outputs.tag }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Generate image tag
      id: image-tag
      run: |
        if [ "${{ github.ref }}" == "refs/heads/main" ] || [ "${{ github.ref }}" == "refs/heads/master" ]; then
          echo "tag=latest" >> $GITHUB_OUTPUT
        else
          echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
        fi
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    - name: Get ACR login server from Terraform
      id: acr-info
      run: |
        # Setup Terraform backend (since this is a separate job)
        if ! az storage account show --name tfstatezoneapi --resource-group rg-terraform-state >/dev/null 2>&1; then
          echo "Setting up Terraform backend..."
          ./scripts/setup-terraform-backend.sh
        else
          echo "Terraform backend already exists"
        fi
        
        cd terraform
        # Initialize Terraform with backend
        terraform init
        ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
        ACR_USERNAME=$(terraform output -raw acr_admin_username)
        ACR_PASSWORD=$(terraform output -raw acr_admin_password)
        echo "::add-mask::$ACR_PASSWORD"
        echo "login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
        echo "username=$ACR_USERNAME" >> $GITHUB_OUTPUT
        echo "password=$ACR_PASSWORD" >> $GITHUB_OUTPUT
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ steps.acr-info.outputs.login-server }}
        username: ${{ steps.acr-info.outputs.username }}
        password: ${{ steps.acr-info.outputs.password }}
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.acr-info.outputs.login-server }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}
        labels: |
          org.opencontainers.image.title=${{ env.IMAGE_NAME }}
          org.opencontainers.image.description=ZoneAPI - Healthcare Appointment Management System
          org.opencontainers.image.source=${{ github.repository }}
          org.opencontainers.image.revision=${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

# Migration Job (Industry Best Practice - Separate from Deployment)
  run-migration:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, docker-build-push]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ needs.deploy-infrastructure.outputs.resource-group }} \
          --name ${{ needs.deploy-infrastructure.outputs.aks-cluster-name }} \
          --overwrite-existing

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    - name: Get Infrastructure Details
      id: infra
      run: |
        # Setup Terraform backend
        if ! az storage account show --name tfstatezoneapi --resource-group rg-terraform-state >/dev/null 2>&1; then
          echo "Setting up Terraform backend..."
          ./scripts/setup-terraform-backend.sh
        fi
        
        cd terraform
        terraform init
        ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
        POSTGRES_HOST=$(terraform output -raw postgres_server_fqdn)
        
        echo "acr-login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
        echo "postgres-host=$POSTGRES_HOST" >> $GITHUB_OUTPUT
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    - name: Create namespace and secrets
      run: |
        echo "=== Creating namespace and secrets ==="
        kubectl create namespace zoneapi --dry-run=client -o yaml | kubectl apply -f -
        
        # Create database secret
        kubectl create secret generic zoneapi-db-secret \
          --from-literal=password="${{ secrets.POSTGRES_ADMIN_PASSWORD }}" \
          --namespace=zoneapi \
          --dry-run=client -o yaml | kubectl apply -f -
        
        echo "✅ Namespace and secrets created"

    - name: Run Database Migration (efbundle Approach)
      timeout-minutes: 15
      run: |
        echo "=== Running Database Migration (efbundle Industry Best Practice) ==="
        
        # Set environment variables for migration script
        export ACR_LOGIN_SERVER="${{ steps.infra.outputs.acr-login-server }}"
        export DATABASE_HOST="${{ steps.infra.outputs.postgres-host }}"
        export DB_PASSWORD="${{ secrets.POSTGRES_ADMIN_PASSWORD }}"
        export IMAGE_TAG="${{ needs.docker-build-push.outputs.image-tag }}"
        export NAMESPACE="zoneapi"
        export TIMEOUT="600"
        
        echo "Migration Configuration:"
        echo "- ACR: $ACR_LOGIN_SERVER"
        echo "- Database Host: $DATABASE_HOST"  
        echo "- Image Tag: $IMAGE_TAG"
        echo "- Namespace: $NAMESPACE"
        echo "- Timeout: $TIMEOUT seconds"
        
        # Setup Helm
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
        
        # Make script executable
        chmod +x ./scripts/run-migration.sh
        
        # Run migration using efbundle approach
        ./scripts/run-migration.sh
    
    - name: Verify Migration Success
      if: always()
      run: |
        echo "=== Migration Job Status ==="
        kubectl get jobs -n zoneapi -l app.kubernetes.io/component=migration
        
        echo "=== Migration Events ==="
        kubectl get events --namespace=zoneapi --sort-by='.lastTimestamp' | tail -20

  # Application Deployment Job (Completely Separate)
  deploy-application:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, docker-build-push, run-migration]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}
    
    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ needs.deploy-infrastructure.outputs.resource-group }} \
          --name ${{ needs.deploy-infrastructure.outputs.aks-cluster-name }} \
          --overwrite-existing

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false

    - name: Get ACR login server from Terraform
      id: acr-info
      run: |
        # Setup Terraform backend
        if ! az storage account show --name tfstatezoneapi --resource-group rg-terraform-state >/dev/null 2>&1; then
          echo "Setting up Terraform backend..."
          ./scripts/setup-terraform-backend.sh
        fi
        
        cd terraform
        terraform init
        ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
        echo "login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    - name: Deploy Application (Post-Migration)
      timeout-minutes: 10
      run: |
        echo "=== DEPLOYING APPLICATION (POST-MIGRATION) ==="
        echo "Image: ${{ steps.acr-info.outputs.login-server }}/${{ env.IMAGE_NAME }}:${{ needs.docker-build-push.outputs.image-tag }}"
        echo "Database: ${{ needs.deploy-infrastructure.outputs.postgres-host }}"
        
        # Deploy application with proper health checks enabled
        helm upgrade --install zoneapi ./charts/zoneapi \
          --namespace zoneapi \
          --set migration.enabled=false \
          --set image.repository=${{ steps.acr-info.outputs.login-server }}/${{ env.IMAGE_NAME }} \
          --set image.tag=${{ needs.docker-build-push.outputs.image-tag }} \
          --set imagePullSecrets[0].name=acr-secret \
          --set database.host=${{ needs.deploy-infrastructure.outputs.postgres-host }} \
          --set database.password=${{ secrets.POSTGRES_ADMIN_PASSWORD }} \
          --set livenessProbe.enabled=true \
          --set readinessProbe.enabled=true \
          --set replicaCount=1 \
          --wait --timeout=8m \
          --debug
    
    - name: Verify Deployment
      if: always()
      run: |
        echo "=== DEPLOYMENT VERIFICATION ==="
        
        echo "=== Pods Status ==="
        kubectl get pods -n zoneapi -o wide
        
        echo "=== Services ==="
        kubectl get services -n zoneapi -o wide
        
        echo "=== Recent Events ==="
        kubectl get events -n zoneapi --sort-by='.lastTimestamp' | tail -20
        
        echo "=== Pod Logs (if any issues) ==="
        kubectl logs -l app.kubernetes.io/name=zoneapi -n zoneapi --tail=50 || echo "No pod logs available"
    
    - name: Health Check Test
      run: |
        echo "=== HEALTH CHECK TEST ==="
        
        # Get pod name
        pod_name=$(kubectl get pods -n zoneapi -l app.kubernetes.io/name=zoneapi -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
        
        if [ -n "$pod_name" ]; then
          echo "Testing pod: $pod_name"
          
          # Wait for pod to be ready
          kubectl wait --for=condition=ready pod/$pod_name -n zoneapi --timeout=120s
          
          # Test health endpoint
          echo "Testing health endpoint..."
          kubectl exec -n zoneapi $pod_name -- curl -f http://localhost:8080/health
          
          echo "✅ Health check passed!"
        else
          echo "⚠️  No pods found to test"
        fi 