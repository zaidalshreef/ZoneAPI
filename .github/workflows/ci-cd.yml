name: CI/CD Pipeline

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master ]

env:
  IMAGE_NAME: zoneapi
  HELM_VERSION: 3.12.0

permissions:
  contents: read
  security-events: write
  actions: read
  id-token: write
  pull-requests: read

jobs:
  # Build and Test Job
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 7.0.x
    
    - name: Restore dependencies
      run: dotnet restore ZoneAPI/ZoneAPI.csproj
    
    - name: Build application
      run: dotnet build ZoneAPI/ZoneAPI.csproj --no-restore --configuration Release
    
    - name: Run tests
      run: dotnet test ZoneAPI/ZoneAPI.csproj --no-build --configuration Release --verbosity normal
    
    # Upload build artifacts
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts
        path: ZoneAPI/bin/Release/
        retention-days: 1

  # Infrastructure Deployment Job
  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: [build-and-test]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    outputs:
      aks-cluster-name: ${{ steps.terraform-output.outputs.aks-cluster-name }}
      resource-group: ${{ steps.terraform-output.outputs.resource-group }}
      postgres-host: ${{ steps.terraform-output.outputs.postgres-host }}
      acr-login-server: ${{ steps.terraform-output.outputs.acr-login-server }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    - name: Terraform Format Check
      run: terraform fmt -check
      working-directory: ./terraform
    
    - name: Setup Terraform Backend (if needed)
      run: |
        # Check if backend storage account exists, create if not
        if ! az storage account show --name tfstatezoneapi --resource-group rg-terraform-state >/dev/null 2>&1; then
          echo "Setting up Terraform backend..."
          ./scripts/setup-terraform-backend.sh
        else
          echo "Terraform backend already exists"
        fi
    
    - name: Terraform Init
      run: terraform init
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    - name: Terraform Plan
      run: terraform plan -out=tfplan
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_VAR_postgres_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
    
    - name: Terraform Apply
      run: terraform apply -auto-approve tfplan
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        TF_VAR_postgres_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
    
    - name: Get Terraform Outputs
      id: terraform-output
      run: |
        echo "aks-cluster-name=$(terraform output -raw aks_cluster_name)" >> $GITHUB_OUTPUT
        echo "resource-group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
        echo "postgres-host=$(terraform output -raw postgres_server_fqdn)" >> $GITHUB_OUTPUT
        echo "acr-login-server=$(terraform output -raw acr_login_server)" >> $GITHUB_OUTPUT
      working-directory: ./terraform
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

  # Docker Build and Push Job
  docker-build-push:
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    outputs:
      image-tag: ${{ steps.image-tag.outputs.tag }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Generate image tag
      id: image-tag
      run: |
        if [ "${{ github.ref }}" == "refs/heads/main" ] || [ "${{ github.ref }}" == "refs/heads/master" ]; then
          echo "tag=latest" >> $GITHUB_OUTPUT
        else
          echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
        fi
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    - name: Get ACR login server from Terraform
      id: acr-info
      run: |
        # Setup Terraform backend (since this is a separate job)
        if ! az storage account show --name tfstatezoneapi --resource-group rg-terraform-state >/dev/null 2>&1; then
          echo "Setting up Terraform backend..."
          ./scripts/setup-terraform-backend.sh
        else
          echo "Terraform backend already exists"
        fi
        
        cd terraform
        # Initialize Terraform with backend
        terraform init
        ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
        ACR_USERNAME=$(terraform output -raw acr_admin_username)
        ACR_PASSWORD=$(terraform output -raw acr_admin_password)
        echo "::add-mask::$ACR_PASSWORD"
        echo "login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
        echo "username=$ACR_USERNAME" >> $GITHUB_OUTPUT
        echo "password=$ACR_PASSWORD" >> $GITHUB_OUTPUT
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ steps.acr-info.outputs.login-server }}
        username: ${{ steps.acr-info.outputs.username }}
        password: ${{ steps.acr-info.outputs.password }}
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.acr-info.outputs.login-server }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}
        labels: |
          org.opencontainers.image.title=${{ env.IMAGE_NAME }}
          org.opencontainers.image.description=ZoneAPI - Healthcare Appointment Management System
          org.opencontainers.image.source=${{ github.repository }}
          org.opencontainers.image.revision=${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: üîí Run Trivy Security Scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.acr-info.outputs.login-server }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: üìä Upload Trivy Scan Results to GitHub Security Tab
      if: always() && github.event_name != 'pull_request'
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results.sarif'
        category: 'trivy-container-image'

    - name: üîç Run Trivy Filesystem Scan
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'table'
        exit-code: '1'
        ignore-unfixed: true
        severity: 'CRITICAL,HIGH'

    - name: üìã Generate Trivy Security Report
      if: always()
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.acr-info.outputs.login-server }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}
        format: 'table'
        output: 'trivy-image-report.txt'

    - name: üì§ Upload Security Reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: trivy-security-reports
        path: |
          trivy-results.sarif
          trivy-image-report.txt
        retention-days: 30

  # Application Deployment Job (with Init Container Migration)
  deploy-application:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, docker-build-push]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: ${{ env.HELM_VERSION }}
    
    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ needs.deploy-infrastructure.outputs.resource-group }} \
          --name ${{ needs.deploy-infrastructure.outputs.aks-cluster-name }} \
          --overwrite-existing
    
    - name: üîß Validate Deployment Configuration
      run: |
        echo "=== üîß VALIDATING DEPLOYMENT CONFIGURATION ==="
        
        # Validate required variables
        ACR_LOGIN_SERVER="${{ needs.deploy-infrastructure.outputs.acr-login-server }}"
        IMAGE_TAG="${{ needs.docker-build-push.outputs.image-tag }}"
        POSTGRES_HOST="${{ needs.deploy-infrastructure.outputs.postgres-host }}"
        DB_PASSWORD="${{ secrets.POSTGRES_ADMIN_PASSWORD }}"
        
        echo "Deployment Configuration:"
        echo "- ACR Login Server: ${ACR_LOGIN_SERVER}"
        echo "- Image Tag: ${IMAGE_TAG}"
        echo "- PostgreSQL Host: ${POSTGRES_HOST}"
        echo "- Password: ${DB_PASSWORD:+[PROVIDED]}"
        
        # Validate all required values are present
        if [ -z "$ACR_LOGIN_SERVER" ] || [ -z "$IMAGE_TAG" ] || [ -z "$POSTGRES_HOST" ] || [ -z "$DB_PASSWORD" ]; then
          echo "‚ùå Missing required deployment variables"
          exit 1
        fi
        
        echo "‚úÖ All deployment variables validated successfully!"

    - name: üöÄ Deploy Application (with Init Container Migration)
      timeout-minutes: 5
      run: |
        echo "=== üöÄ DEPLOYING APPLICATION WITH INIT CONTAINER MIGRATION ==="
        echo "Image: ${{ needs.deploy-infrastructure.outputs.acr-login-server }}/${{ env.IMAGE_NAME }}:${{ needs.docker-build-push.outputs.image-tag }}"
        echo "Database: ${{ needs.deploy-infrastructure.outputs.postgres-host }}"
        
        # Deploy application with proven working configuration
        helm upgrade --install zoneapi ./charts/zoneapi \
          --namespace zoneapi \
          --create-namespace \
          --set image.repository=${{ needs.deploy-infrastructure.outputs.acr-login-server }}/${{ env.IMAGE_NAME }} \
          --set image.tag=${{ needs.docker-build-push.outputs.image-tag }} \
          --set imagePullSecrets[0].name=acr-secret \
          --set database.host=${{ needs.deploy-infrastructure.outputs.postgres-host }} \
          --set database.password=${{ secrets.POSTGRES_ADMIN_PASSWORD }} \
          --set livenessProbe.enabled=true \
          --set readinessProbe.enabled=true \
          --set replicaCount=1 \
          --force \
          --wait --timeout=5m \
          --debug
        
        echo "‚úÖ Application deployed successfully!"
    
    - name: üîç Verify Deployment & Health
      if: always()
      run: |
        echo "=== üîç DEPLOYMENT VERIFICATION & HEALTH CHECKS ==="
        
        echo "=== Pods Status ==="
        kubectl get pods -n zoneapi -o wide
        
        echo "=== Services ==="
        kubectl get services -n zoneapi -o wide
        
        echo "=== Ingress ==="
        kubectl get ingress -n zoneapi -o wide || echo "No ingress found"
        
        # Get the main application pod
        app_pod=$(kubectl get pods -n zoneapi -l app.kubernetes.io/name=zoneapi -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
        
        if [ -n "$app_pod" ]; then
          echo ""
          echo "=== Application Pod: $app_pod ==="
          
          # Check pod status
          pod_status=$(kubectl get pod "$app_pod" -n zoneapi -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
          ready_status=$(kubectl get pod "$app_pod" -n zoneapi -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "Unknown")
          
          echo "Pod Status: $pod_status"
          echo "Ready Status: $ready_status"
          
          # Verify environment variables are correctly set
          echo ""
          echo "=== Environment Variables Verification ==="
          kubectl exec -n zoneapi "$app_pod" -- env | grep -E "(ConnectionStrings|DB_)" | sort || echo "Could not retrieve environment variables"
          
          # Test health endpoint
          echo ""
          echo "=== Health Endpoint Test ==="
          if kubectl exec -n zoneapi "$app_pod" -- curl -f --max-time 10 http://localhost:8080/health 2>/dev/null; then
            echo ""
            echo "‚úÖ Health check passed!"
          else
            echo "‚ùå Health check failed!"
            
            echo ""
            echo "=== Application Logs for Debugging ==="
            kubectl logs "$app_pod" -n zoneapi --tail=30 || echo "Could not retrieve logs"
          fi
        else
          echo "‚ö†Ô∏è No application pod found"
        fi
        
        echo ""
        echo "=== Recent Events ==="
        kubectl get events -n zoneapi --sort-by='.lastTimestamp' | tail -20
    
    - name: üèÅ Final Health & API Validation
      run: |
        echo "=== üèÅ FINAL HEALTH & API VALIDATION ==="
        
        # Get pod name
        pod_name=$(kubectl get pods -n zoneapi -l app.kubernetes.io/name=zoneapi -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
        
        if [ -n "$pod_name" ]; then
          echo "Testing pod: $pod_name"
          
          # Wait for pod to be ready with timeout
          echo "Waiting for pod to be ready..."
          if kubectl wait --for=condition=ready pod/$pod_name -n zoneapi --timeout=120s; then
            echo "‚úÖ Pod is ready!"
            
            # Test health endpoint with detailed response
            echo ""
            echo "Testing health endpoint..."
            if health_response=$(kubectl exec -n zoneapi "$pod_name" -- curl -f --max-time 15 http://localhost:8080/health 2>/dev/null); then
              echo "‚úÖ Health endpoint responded successfully!"
              echo "Health Response: $health_response"
              
              # Parse the health response to verify database connectivity
              if echo "$health_response" | grep -q '"connected":true'; then
                echo "‚úÖ Database connectivity confirmed!"
              else
                echo "‚ö†Ô∏è Database connectivity issue detected in health response"
              fi
              
              # Test a simple API endpoint
              echo ""
              echo "Testing Doctors API endpoint..."
              if kubectl exec -n zoneapi "$pod_name" -- curl -f --max-time 10 http://localhost:8080/api/doctors 2>/dev/null; then
                echo ""
                echo "‚úÖ API endpoints are accessible!"
              else
                echo "‚ö†Ô∏è API endpoint test failed (may be expected if no data)"
              fi
              
            else
              echo "‚ùå Health endpoint test failed!"
              echo "Checking pod logs for issues..."
              kubectl logs "$pod_name" -n zoneapi --tail=20
              exit 1
            fi
          else
            echo "‚ùå Pod failed to become ready within timeout"
            kubectl describe pod "$pod_name" -n zoneapi
            exit 1
          fi
        else
          echo "‚ùå No pods found to test"
          exit 1
        fi
        
        echo ""
        echo "üéâ All deployment validation tests passed!"
        
        # Show external endpoint
        external_ip=$(kubectl get service zoneapi -n zoneapi -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
        if [ "$external_ip" != "pending" ] && [ -n "$external_ip" ]; then
          echo ""
          echo "üåê Application is accessible at:"
          echo "   Health Check: http://$external_ip:8080/health"
          echo "   Doctors API:  http://$external_ip:8080/api/doctors"
          echo "   Patients API: http://$external_ip:8080/api/patients"
        else
          echo ""
          echo "‚è≥ LoadBalancer IP is still provisioning..."
        fi
    
    - name: üß™ Run Comprehensive Deployment Validation
      run: |
        echo "=== üß™ COMPREHENSIVE DEPLOYMENT VALIDATION ==="
        
        # Make script executable and run comprehensive validation
        chmod +x ./scripts/validate-deployment.sh
        
        if ./scripts/validate-deployment.sh; then
          echo ""
          echo "‚úÖ Comprehensive validation completed successfully!"
        else
          echo ""
          echo "‚ùå Comprehensive validation failed!"
          exit 1
        fi 