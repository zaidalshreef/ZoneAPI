name: Manual Deployment Test (No Helm)

on:
  workflow_dispatch:
    inputs:
      clean_before_deploy:
        description: 'Clean existing resources before deployment'
        required: false
        default: true
        type: boolean
      check_secrets_only:
        description: 'Only check secrets and cluster state (no deployment)'
        required: false
        default: false
        type: boolean

env:
  IMAGE_NAME: zoneapi

jobs:
  manual-deploy-test:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Get Infrastructure Info
      id: infra-info
      run: |
        # Setup Terraform backend
        if ! az storage account show --name tfstatezoneapi --resource-group rg-terraform-state >/dev/null 2>&1; then
          echo "Setting up Terraform backend..."
          ./scripts/setup-terraform-backend.sh
        fi
        
        cd terraform
        terraform init
        
        # Check if infrastructure is deployed
        if ! terraform show &>/dev/null; then
          echo "❌ No Terraform state found - infrastructure may not be deployed"
          echo "Please run the main CI/CD pipeline first to deploy infrastructure"
          exit 1
        fi
        
        # Get outputs with error checking
        if ! ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server 2>/dev/null); then
          echo "❌ Failed to get ACR login server from Terraform state"
          terraform output
          exit 1
        fi
        
        if ! POSTGRES_HOST=$(terraform output -raw postgres_server_fqdn 2>/dev/null); then
          echo "❌ Failed to get PostgreSQL host from Terraform state"
          terraform output
          exit 1
        fi
        
        if ! RESOURCE_GROUP=$(terraform output -raw resource_group_name 2>/dev/null); then
          echo "❌ Failed to get resource group name from Terraform state"
          terraform output
          exit 1
        fi
        
        if ! AKS_CLUSTER=$(terraform output -raw aks_cluster_name 2>/dev/null); then
          echo "❌ Failed to get AKS cluster name from Terraform state"
          terraform output
          exit 1
        fi
        
        echo "acr-registry=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
        echo "postgres-host=$POSTGRES_HOST" >> $GITHUB_OUTPUT
        echo "resource-group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
        echo "aks-cluster=$AKS_CLUSTER" >> $GITHUB_OUTPUT
        
        echo "✅ ACR Registry: $ACR_LOGIN_SERVER"
        echo "✅ PostgreSQL Host: $POSTGRES_HOST"
        echo "✅ Resource Group: $RESOURCE_GROUP"
        echo "✅ AKS Cluster: $AKS_CLUSTER"
      env:
        ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
        ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

    - name: Connect to AKS
      run: |
        az aks get-credentials --resource-group ${{ steps.infra-info.outputs.resource-group }} --name ${{ steps.infra-info.outputs.aks-cluster }} --overwrite-existing
        kubectl config current-context

    - name: Set Environment Variables
      run: |
        echo "ACR_REGISTRY=${{ steps.infra-info.outputs.acr-registry }}" >> $GITHUB_ENV
        echo "DB_HOST=${{ steps.infra-info.outputs.postgres-host }}" >> $GITHUB_ENV
        echo "POSTGRES_ADMIN_PASSWORD=${{ secrets.POSTGRES_ADMIN_PASSWORD }}" >> $GITHUB_ENV

    - name: Check Secrets and Current State
      run: |
        echo "=== CHECKING KUBERNETES SECRETS AND CURRENT STATE ==="
        ./scripts/manual-deploy.sh check

    - name: Clean Existing Resources
      if: ${{ inputs.clean_before_deploy == true && inputs.check_secrets_only == false }}
      run: |
        echo "=== CLEANING EXISTING RESOURCES ==="
        
        # Remove Helm deployment if it exists (check both namespaces)
        if helm list --all-namespaces | grep -q zoneapi; then
          echo "Removing existing Helm deployment..."
          # Try both zoneapi namespace and default namespace
          helm uninstall zoneapi -n zoneapi 2>/dev/null || echo "No Helm release in zoneapi namespace"
          helm uninstall zoneapi 2>/dev/null || echo "No Helm release in default namespace"
        fi
        
        # Clean manual deployment resources
        ./scripts/manual-deploy.sh clean
        
        # Wait a bit for cleanup
        sleep 10

    - name: Check Docker Image Availability (Optional)
      if: ${{ inputs.check_secrets_only == false }}
      continue-on-error: true
      run: |
        echo "=== CHECKING DOCKER IMAGE AVAILABILITY ==="
        
        # Login to ACR
        az acr login --name $(echo "${{ steps.infra-info.outputs.acr-registry }}" | cut -d'.' -f1)
        
        # Check if latest image exists (don't fail if missing)
        IMAGE_REPO="${{ steps.infra-info.outputs.acr-registry }}/${{ env.IMAGE_NAME }}"
        
        echo "Checking for image: $IMAGE_REPO:latest"
        
        if az acr repository show-manifests --name $(echo "${{ steps.infra-info.outputs.acr-registry }}" | cut -d'.' -f1) --repository ${{ env.IMAGE_NAME }} --query "[?tags!=null && contains(tags, 'latest')]" -o tsv 2>/dev/null; then
          echo "✓ Latest image found in registry"
        else
          echo "⚠️  Latest image not found in registry - this is expected on first deployment"
          echo "Available repositories:"
          az acr repository list --name $(echo "${{ steps.infra-info.outputs.acr-registry }}" | cut -d'.' -f1) --output table 2>/dev/null || echo "No repositories found"
          echo "Manual deployment will proceed anyway..."
        fi

    - name: Deploy with Manual Method
      if: ${{ inputs.check_secrets_only == false }}
      timeout-minutes: 25
      run: |
        cd $GITHUB_WORKSPACE
        echo "=== MANUAL DEPLOYMENT WITHOUT HELM ==="
        echo "Registry: $ACR_REGISTRY"
        echo "Database Host: $DB_HOST"
        echo "Password Length: ${#POSTGRES_ADMIN_PASSWORD}"
        
        # Run manual deployment
        ./scripts/manual-deploy.sh deploy

    - name: Test Application Health
      if: ${{ inputs.check_secrets_only == false }}
      timeout-minutes: 5
      run: |
        echo "=== TESTING APPLICATION HEALTH ==="
        
        # Wait for service to be ready
        echo "Waiting for deployment to be ready..."
        kubectl wait --for=condition=available --timeout=300s deployment/zoneapi || echo "Deployment not ready within timeout"
        
        # Check if service exists
        if ! kubectl get service zoneapi &>/dev/null; then
          echo "❌ Service zoneapi not found"
          echo "Available services:"
          kubectl get services
          exit 1
        fi
        
        # Port forward and test health endpoint
        echo "Starting port-forward to service/zoneapi..."
        kubectl port-forward service/zoneapi 8080:8080 &
        PF_PID=$!
        
        # Wait for port forward to be ready and test connectivity
        echo "Waiting for port-forward to be established..."
        for i in {1..10}; do
          if netstat -ln | grep ":8080 " >/dev/null 2>&1; then
            echo "✅ Port-forward established"
            break
          fi
          echo "⏳ Waiting for port-forward... ($i/10)"
          sleep 2
        done
        
        # Test health endpoint
        MAX_ATTEMPTS=10
        ATTEMPT=1
        
        while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
          echo "Testing health endpoint (attempt $ATTEMPT/$MAX_ATTEMPTS)..."
          
          if curl -f -s http://localhost:8080/health; then
            echo "✓ Health check passed!"
            break
          else
            echo "❌ Health check failed, retrying in 10 seconds..."
            sleep 10
            ((ATTEMPT++))
          fi
        done
        
        # Cleanup port forward
        kill $PF_PID || true
        
        if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
          echo "❌ Health check failed after $MAX_ATTEMPTS attempts"
          
          echo ""
          echo "=== APPLICATION LOGS ==="
          kubectl logs -l app.kubernetes.io/name=zoneapi --tail=50
          
          echo ""
          echo "=== POD STATUS ==="
          kubectl describe pods -l app.kubernetes.io/name=zoneapi
          
          exit 1
        fi

    - name: Run API Tests
      if: ${{ inputs.check_secrets_only == false }}
      timeout-minutes: 5
      run: |
        echo "=== RUNNING API TESTS ==="
        
        # Port forward for testing
        echo "Starting port-forward for API testing..."
        kubectl port-forward service/zoneapi 8080:8080 &
        PF_PID=$!
        
        # Wait for port forward to be ready
        for i in {1..10}; do
          if netstat -ln | grep ":8080 " >/dev/null 2>&1; then
            echo "✅ Port-forward ready for API testing"
            break
          fi
          echo "⏳ Waiting for port-forward... ($i/10)"
          sleep 2
        done
        
        # Test various endpoints
        echo "Testing /health endpoint..."
        curl -f http://localhost:8080/health || echo "Health endpoint failed"
        
        echo ""
        echo "Testing /api/doctors endpoint..."
        curl -f http://localhost:8080/api/doctors || echo "Doctors endpoint failed"
        
        echo ""
        echo "Testing /api/patients endpoint..."
        curl -f http://localhost:8080/api/patients || echo "Patients endpoint failed"
        
        echo ""
        echo "Testing /api/appointments endpoint..."
        curl -f http://localhost:8080/api/appointments || echo "Appointments endpoint failed"
        
        # Cleanup
        kill $PF_PID || true
        
        echo "✓ API tests completed!"

    - name: Deployment Summary
      if: always()
      run: |
        echo "=== DEPLOYMENT SUMMARY ==="
        echo "Manual deployment test completed"
        echo ""
        
        if [ "${{ inputs.check_secrets_only }}" == "true" ]; then
          echo "Mode: Secrets check only"
        else
          echo "Mode: Full deployment test"
          
          echo ""
          echo "=== FINAL RESOURCE STATUS ==="
          kubectl get all -l app.kubernetes.io/name=zoneapi -o wide || echo "No resources with app.kubernetes.io/name=zoneapi label"
          
          echo ""
          echo "=== ALL RESOURCES ==="
          kubectl get all -o wide
          
          echo ""
          echo "=== SECRETS STATUS ==="
          kubectl get secrets zoneapi-db-secret -o yaml 2>/dev/null || echo "Secret zoneapi-db-secret not found"
        fi
        
        echo ""
        echo "=== LOGS ==="
        if kubectl get pods -l app.kubernetes.io/name=zoneapi -o name | head -1; then
          kubectl logs -l app.kubernetes.io/name=zoneapi --tail=20
        else
          echo "No pods found with app.kubernetes.io/name=zoneapi label"
          echo "All pods:"
          kubectl get pods
        fi

    - name: Cleanup on Failure
      if: failure()
      run: |
        echo "=== CLEANUP ON FAILURE ==="
        echo "Gathering debugging information..."
        
        echo ""
        echo "=== ALL RESOURCES ==="
        kubectl get all -o wide
        
        echo ""
        echo "=== EVENTS ==="
        kubectl get events --sort-by=.metadata.creationTimestamp
        
        echo ""
        echo "=== DESCRIBING FAILED RESOURCES ==="
        kubectl describe pods -l app.kubernetes.io/name=zoneapi || true
        kubectl describe deployment zoneapi || true
        kubectl describe job zoneapi-migration-latest || true
        
        # Optional: Clean up failed deployment
        echo "Cleaning up failed deployment..."
        ./scripts/manual-deploy.sh clean 